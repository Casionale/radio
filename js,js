class RadioManager {
    constructor(apiUrl, updateInterval = 5000) {
        this.apiUrl = apiUrl;                     // Адрес API или прямой поток
        this.updateInterval = updateInterval;     // Интервал обновления JSON
        this.data = null;                         // Текущее состояние данных станции
        this.timerInterval = null;                // Интервал таймера (обновление времени песни)
        this.timeElapsed = 0;                     // Текущее время проигрывания (в секундах)
        this.isDirectStream = !apiUrl.includes('/api/') || apiUrl.endsWith('.mp3') || apiUrl.endsWith('.aac'); // Флаг: прямой поток?

        this.start(); // сразу запускаем

        this.timesong = 0;

        // Создаём аудиоплеер сразу
        this.audio = new Audio();
        this.audio.crossOrigin = "anonymous"; // если нужно
        this.audio.src = ""; // пока пусто
        this.audio.load();
    }

    // Метод для запроса данных с сервера
    async fetchData() {
        try {
            if (this.isDirectStream) {
                throw new Error('Direct stream mode'); // Пропускаем fetch для прямых потоков
            }
            const response = await fetch(this.apiUrl);
            if (!response.ok) throw new Error(`Ошибка ${response.status}`);
            const json = await response.json();
            this.data = json;
            this.timesong = this.data?.now_playing?.elapsed;
            this.timeElapsed = 0;

            this.updateHTML();
        } catch (error) {
            console.warn('Fetch failed, switching to direct stream mode:', error);
            this.isDirectStream = true; // Переключаем флаг навсегда
            // Fallback данные для UI
            this.data = {
                now_playing: { song: { title: 'Неизвестный трек', artist: 'Неизвестный исполнитель', art: '' } },
                playing_next: { song: { title: 'N/A', artist: 'N/A', art: '' } },
                song_history: Array(5).fill({ song: { title: 'N/A', artist: 'N/A', art: '' } }),
                station: { listen_url: this.apiUrl, playlist_m3u_url: '' }
            };
            this.updateHTML();
        }
    }

    // Метод для расстановки данных в HTML (реализуешь сам)
    updateHTML() {
        this.updateElement(".album-title", this.data?.now_playing?.song?.title);
        
        this.updateElement(".album-artist", this.data?.now_playing?.song?.artist);
        this.updateElement(".album-title", this.data?.now_playing?.song?.title);
        this.updateImage(".album-artwork", this.data?.now_playing?.song?.art);

        this.updateElement(".mini-album-artist", this.data?.now_playing?.song?.artist);
        this.updateElement(".mini-album-title", this.data?.now_playing?.song?.title);
        this.updateImage(".mini-album-artwork", this.data?.now_playing?.song?.art);

        this.updateElement("section.queue-section:nth-child(1) > div:nth-child(2) > div:nth-child(1) > div:nth-child(2) > div:nth-child(1)", this.data?.playing_next?.song?.title);
        this.updateElement("section.queue-section:nth-child(1) > div:nth-child(2) > div:nth-child(1) > div:nth-child(2) > div:nth-child(2)", this.data?.playing_next?.song?.artist);
        this.updateImage("section.queue-section:nth-child(1) > div:nth-child(2) > div:nth-child(1) > img:nth-child(1)", this.data?.playing_next?.song?.art);

        this.updateElement("section.queue-section:nth-child(2) > div:nth-child(2) > div:nth-child(1) > div:nth-child(2) > div:nth-child(1)", this.data?.song_history[0]?.song?.title);
        this.updateElement("section.queue-section:nth-child(2) > div:nth-child(2) > div:nth-child(1) > div:nth-child(2) > div:nth-child(2)", this.data?.song_history[0]?.song?.artist);
        this.updateImage("section.queue-section:nth-child(2) > div:nth-child(2) > div:nth-child(1) > img:nth-child(1)", this.data?.song_history[0]?.song?.art);

        this.updateElement("div.track-item:nth-child(2) > div:nth-child(2) > div:nth-child(1)", this.data?.song_history[1]?.song?.title);
        this.updateElement("div.track-item:nth-child(2) > div:nth-child(2) > div:nth-child(2)", this.data?.song_history[1]?.song?.artist);
        this.updateImage("div.track-item:nth-child(2) > img:nth-child(1)", this.data?.song_history[1]?.song?.art);

        this.updateElement("div.track-item:nth-child(3) > div:nth-child(2) > div:nth-child(1)", this.data?.song_history[2]?.song?.title);
        this.updateElement("div.track-item:nth-child(3) > div:nth-child(2) > div:nth-child(2)", this.data?.song_history[2]?.song?.artist);
        this.updateImage("div.track-item:nth-child(3) > img:nth-child(1)", this.data?.song_history[2]?.song?.art);

        this.updateElement("div.track-item:nth-child(4) > div:nth-child(2) > div:nth-child(1)", this.data?.song_history[3]?.song?.title);
        this.updateElement("div.track-item:nth-child(4) > div:nth-child(2) > div:nth-child(2)", this.data?.song_history[3]?.song?.artist);
        this.updateImage("div.track-item:nth-child(4) > img:nth-child(1)", this.data?.song_history[3]?.song?.art);

        this.updateElement("div.track-item:nth-child(5) > div:nth-child(2) > div:nth-child(1)", this.data?.song_history[4]?.song?.title);
        this.updateElement("div.track-item:nth-child(5) > div:nth-child(2) > div:nth-child(2)", this.data?.song_history[4]?.song?.artist);
        this.updateImage("div.track-item:nth-child(5) > img:nth-child(1)", this.data?.song_history[4]?.song?.art);
        
        this.updateOnClick(".control-buttons > button:nth-child(1)",()=>{
            this.downloadFile(this.data?.station?.playlist_m3u_url || '');
        });

        // Обновляем Media Session API для мини-плеера и экрана блокировки
        this.updateMediaSession();

        // Обновляем мобильное меню если оно активно
        if (typeof updateMobileMenuContent === 'function') {
            updateMobileMenuContent();
        }

        // TODO: реализовать отображение данных на странице
    }

    /**
     * Обновляет Media Session API для мини-плеера и экрана блокировки
     */
    updateMediaSession() {
        if ('mediaSession' in navigator) {
            const song = this.data?.now_playing?.song || { title: 'Неизвестный трек', artist: 'Неизвестный исполнитель' };
            const station = this.data?.station || { name: 'Пользовательская станция' };

            navigator.mediaSession.metadata = new MediaMetadata({
                title: song.title,
                artist: song.artist,
                album: station.name,
                artwork: [
                    {
                        src: song.art || '../assets/images/albom.png',
                        sizes: '512x512',
                        type: 'image/png'
                    },
                    {
                        src: song.art || '../assets/images/albom.png',
                        sizes: '256x256',
                        type: 'image/png'
                    }
                ]
            });

            // Обработчики для управления воспроизведением через Media Session
            navigator.mediaSession.setActionHandler('play', () => {
                if (this.audio) {
                    this.audio.play();
                }
            });

            navigator.mediaSession.setActionHandler('pause', () => {
                if (this.audio) {
                    this.audio.pause();
                }
            });

            navigator.mediaSession.setActionHandler('stop', () => {
                if (this.audio) {
                    this.audio.pause();
                    this.audio.currentTime = 0;
                }
            });
        }
    }

    /**
     * Универсальная функция замены содержимого элемента.
     * @param {string} selector — CSS-селектор элемента
     * @param {string|number|null|undefined} value — данные для вставки
     */
    updateElement(selector, value) {
        try {
            const el = document.querySelector(selector);
            if (!el) {
                console.warn(`⚠️ Элемент ${selector} не найден`);
                return;
            }

            // Если данные отсутствуют — очищаем элемент
            el.textContent = value ?? "";
        } catch (err) {
            console.error(`Ошибка при обновлении ${selector}:`, err);
        }
    }

    updateImage(selector, src) {
        try {
            const img = document.querySelector(selector);
            if (!img) {
                console.warn(`⚠️ Элемент ${selector} не найден`);
                return;
            }

            // Определяем fallback изображение в зависимости от селектора
            const fallbackSrc = this.getFallbackImage(selector);

            // Устанавливаем обработчик ошибки загрузки
            img.onerror = function() {
                console.warn(`⚠️ Ошибка загрузки изображения: ${src}, используем fallback: ${fallbackSrc}`);
                this.src = fallbackSrc;
                this.onerror = null; // Убираем обработчик, чтобы избежать бесконечного цикла
            };

            // Устанавливаем обработчик успешной загрузки
            img.onload = function() {
                this.onload = null; // Очищаем обработчик
            };

            // Если src отсутствует или пустой, сразу используем fallback
            if (!src || src.trim() === "") {
                img.src = fallbackSrc;
            } else {
                img.src = src;
            }
        } catch (err) {
            console.error(`Ошибка при обновлении изображения ${selector}:`, err);
        }
    }

    // Метод для определения fallback изображения
    getFallbackImage(selector) {
        // Для основных обложек альбомов
        if (selector.includes('album-artwork') || selector.includes('mini-album-artwork')) {
            return '../assets/images/albom.png';
        }

        // Для изображений треков в истории и очереди
        if (selector.includes('track-image')) {
            return '../assets/images/preloader.png';
        }

        // Для иконок радиостанций
        if (selector.includes('station-icon')) {
            return '../assets/images/preloaderRad.png';
        }

        // Для изображений "следующий трек"
        if (selector.includes('playing_next') || selector.includes('song_history')) {
            return '../assets/images/preloader.png';
        }

        // По умолчанию используем albom.png
        return '../assets/images/albom.png';
    }

    updateOnClick(selector, onClick){
        try {
            const el = document.querySelector(selector);
            if (!el) {
                console.warn(`⚠️ Элемент ${selector} не найден`);
                return;
        }

        // Удаляем предыдущий обработчик, если нужно
        el.onclick = null;

        // Назначаем новый (если он передан)
        if (typeof onClick === "function") {
            el.onclick = onClick;
        }
        } catch (err) {
            console.error(`Ошибка при обновлении onClick для ${selector}:`, err);
        }
    }

    downloadFile(url){
        if (!url) {
            console.warn('No playlist URL for download');
            return;
        }
        console.log('Скачиваю по адресу '+url);
        let a = document.createElement("a");
        a.href = url;
        a.download = "playlist.m3u";
        a.click();
    }

    // Метод для запроса конкретной песни (реализуешь сам)
    requestSong(songName) {
        // TODO: реализовать запрос песни на сервер
    }

    // Метод для обновления таймера проигрывания песни
    startTimer() {
        if (this.isDirectStream) {
            console.log('Timer disabled for direct stream');
            return; // Нет duration в direct-режиме
        }
        if (this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = setInterval(() => {
            this.timeElapsed++;
            this.updateTimerDisplay(); // вызываем каждый раз, когда обновляется время
        }, 1000);
    }

    // Метод для обновления отображения таймера (реализуешь сам)
    updateTimerDisplay() {
        if (this.isDirectStream) {
            this.updateElement("span.time-display:nth-child(1)", '00:00');
            this.updateElement("span.time-display:nth-child(4)", 'N/A');
            document.querySelector('.progress-bar').style.width = '0%';
            return;
        }
        // Получаем данные из this.data
        const playedAt = this.data?.now_playing?.played_at; // timestamp начала воспроизведения
        const duration = this.data?.now_playing?.duration;   // длительность песни в секундах
      
        // Если данных нет — выходим
        if (!playedAt || !duration) {
          return;
        }
      
        // Текущее время в миллисекундах
        const currentTime = new Date().getTime()/1000;
      
        // Прошедшее время в секундах (с округлением до целого)
        const elapsed = Math.floor((currentTime - playedAt));
      
        // Ограничиваем elapsed длительностью песни
        const safeElapsed = Math.min(elapsed, duration);
      
        // Оставшееся время
        const remaining = duration - safeElapsed;
      
        // Форматируем время
        const elapsedStr = formatSeconds(safeElapsed);
        const totalStr = formatSeconds(duration);
      
        // Обновляем отображение:
        // - текущее время (elapsed)
        // - общая длительность (duration)
        this.updateElement("span.time-display:nth-child(1)", elapsedStr);
        this.updateElement("span.time-display:nth-child(4)", totalStr);
      
        // Обновляем ширину прогресс‑бара (в процентах)
        const progressPercent = (safeElapsed / duration) * 100;
        document.querySelector('.progress-bar').style.width = `${progressPercent}%`;
      
      }

    // Метод запуска автоматического обновления данных
    start() {
        this.fetchData();
        this.startTimer();
        this.intervalId = setInterval(() => this.fetchData(), this.updateInterval);
    }

    togglePlayButton(){
        try{    
            this.togglePlay(this.data?.station?.listen_url || this.apiUrl); // Fallback на apiUrl
            
            let paused = this.audio.paused;
            let btn = document.querySelector('button.control-btn:nth-child(2)');
            if (!paused)
                btn.classList.add('playing');
            else
                btn.classList.toggle('playing');
        }
        catch{
            console.error("Нет ссылки на поток!");
        }
    } 

    // Проигрывание / пауза потока
    togglePlay(url) {
        url = url.replace(/^http:/, "https:");
        console.log(url);
        // Если аудиоплеер ещё не создан — создаём
        if (!this.audio) {
            this.audio = new Audio(url);
            this.audio.crossOrigin = "anonymous"; // чтобы не было CORS-проблем
            this.audio.src = url;
        }

        // Если сейчас играет — ставим на паузу
        if (!this.audio.paused) {
            this.audio.pause();
            this.updateVisualizerState(false);
            console.log("⏸️ Радио поставлено на паузу");
        } else {
            // Если остановлено — запускаем (если URL изменился — обновляем)
            if (this.audio.src !== url) {
                this.audio.src = url;
            }
            this.audio.play()
                .then(() => {
                    this.updateVisualizerState(true);
                    console.log("▶️ Радио запущено");
                })
                .catch(err => console.error("Ошибка при воспроизведении:", err));
        }
    }

    // Управление громкостью (значение от 0 до 1)
    setVolume(value) {
        if (this.audio) {
            this.audio.volume = Math.min(Math.max(value, 0), 1); // защита от выхода за диапазон
        }
    }

    stopTimer() {
        if (this.intervalId !== null) {
            clearInterval(this.intervalId);
            this.intervalId = null;
        }

        if (this.timerInterval !== null){
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    }

    // Управление состоянием визуализатора
    updateVisualizerState(isPlaying) {
        if (window.audioVisualizer) {
            window.audioVisualizer.onPlaybackStateChange(isPlaying);
        }
    }
}

// Создаём экземпляр менеджера
window.radio = new RadioManager("https://radio.bakasenpai.ru/api/nowplaying/e621.station");


document.addEventListener("DOMContentLoaded", function(event) {
    play_btn = document.querySelector('button.control-btn:nth-child(2)');

    play_btn.addEventListener("click", () => radio.togglePlay(radio.data?.station?.listen_url || radio.apiUrl)); // Fallback
});



const formatSeconds = (seconds) => {
  const mins = Math.floor(seconds / 60);
  const secs = seconds % 60;
  return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
};


const el = document.querySelector('.seek-bar');
const chatWindowBtn = document.querySelector('#headerButton');

let lastVolume = null;

const observer = new MutationObserver(() => {
    const current = el.style.getPropertyValue('--volume-level');

    if (current !== lastVolume) {
        lastVolume = current;
        
        // твой код реакции на изменение громкости
        const volumeRatio = parseFloat(current) / 100;
        window.radio.setVolume(volumeRatio);
    }
});

observer.observe(el, {
    attributes: true,
    attributeFilter: ['style']
});

chatWindowBtn.addEventListener("click", ()=>{
    window.radio.updateHTML();
});


function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}